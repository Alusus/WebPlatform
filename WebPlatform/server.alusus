@merge module WebPlatform {
    class UiEndpoint {
        def uri: String;
        def filename: String;
        def title: String;
        handler this~init() {}
        handler this~init(uri: String, filename: String, title: String) this.set(uri, filename, title);
        handler this~init(ref[UiEndpoint]) this.set(value.uri, value.filename, value.title);
        handler this=ref[UiEndpoint] this.set(value.uri, value.filename, value.title);
        handler this.set (uri: String, filename: String, title: String) {
            this.uri = uri;
            this.filename = filename;
            this.title = title;
        }
    }
    def uiEndpoints: Array[UiEndpoint];
    def htmlTemplate: String;

    class AssetRoute {
        def uri: String;
        def path: String;
        handler this~init() {}
        handler this~init(uri: String, path: String) this.set(uri, path);
        handler this~init(ref[AssetRoute]) this.set(value.uri, value.path);
        handler this=ref[AssetRoute] this.set(value.uri, value.path);
        handler this.set (uri: String, path: String) {
            this.uri = uri;
            this.path = path;
        }
    }
    def assetRoutes: Array[AssetRoute];

    def AstTemplateMap: alias Map[String, ref[Core.Basic.TiObject]];

    func getElementName (obj: ref[Core.Basic.TiObject]): String {
        def node: ref[Core.Data.Node](castRef[obj, Core.Data.Node]);
        def d: ref[Core.Data.Ast.Definition](castRef[node.owner, Core.Data.Ast.Definition]);
        def binding: ref[Core.Basic.Binding](Core.Basic.getInterface[d, Core.Basic.Binding]);
        def name: ref[Core.Basic.TiStr](castRef[binding.getMember("name"), Core.Basic.TiStr]);
        return name.value;
    }

    func constructElementFullReference (element: ref[Core.Basic.TiObject]): SrdRef[Core.Basic.TiObject] {
        def node: ref[Core.Data.Node](castRef[element, Core.Data.Node]);
        if node.owner~ptr == 0 return SrdRef[Core.Basic.TiObject]();
        def name: String = getElementName(node);
        def identifier: SrdRef[Core.Data.Ast.Identifier] = Core.Basic.newSrdObj[Core.Data.Ast.Identifier].{
            value.value = name;
        };
        def ownerRef: SrdRef[Core.Basic.TiObject] = constructElementFullReference(node.owner.owner);
        if ownerRef.isNull() return identifier
        else return Core.Basic.newSrdObj[Core.Data.Ast.LinkOperator].{
            Core.Basic.MapContainerOf[this].{
                setElement("first", ownerRef);
                setElement("second", identifier);
            };
        };
    }

    func addUiEndpoints (parent: ref[Core.Basic.TiObject]) {
        def elements: Array[ref[Core.Basic.TiObject]] = Spp.astMgr.findElements(
            ast { modifier == "uiEndpoint" || modifier == "منفذ_مرئي" },
            parent,
            Spp.SeekerFlags.SKIP_OWNERS | Spp.SeekerFlags.SKIP_USES | Spp.SeekerFlags.SKIP_CHILDREN
        );
        def i: Int;
        for i = 0, i < elements.getLength(), ++i {
            def modifier: ref[Core.Basic.TiObject](Spp.astMgr.findModifierForElement(elements(i), "uiEndpoint"));
            if modifier~ptr == 0 modifier~no_deref = Spp.astMgr.findModifierForElement(elements(i), "منفذ_مرئي");
            def endpointParams: Array[String];
            if !Spp.astMgr.getModifierStringParams(modifier, endpointParams)
                || endpointParams.getLength() < 2 {
                System.fail(1, "Invalid UI endpoint params");
            }
            addUiEndpoint(elements(i), endpointParams(0), endpointParams(1));
        }
    }

    func addUiEndpoint (fn: ref[Core.Basic.TiObject], uri: String, title: String) {
        def binding: ref[Core.Basic.Binding](Core.Basic.getInterface[fn, Core.Basic.Binding]);
        binding.setMember("name", Core.Basic.TiStr("wasmStart"));
        def wasm: Build.Wasm(fn, "/tmp/endpoint.wasm");
        wasm.addDependency(webPlatformPath + String("/stdlib-min.wasm"));
        wasm.addFlags({ String("--export=malloc"), String("--export=realloc") });
        wasm.generate();
        def wasmFilename: String = String("/") + getElementName(fn) + ".wasm";
        if System.exec(
            webPlatformPath + "/Tools/bin/wasm-opt -O --asyncify /tmp/endpoint.wasm -o /tmp" + wasmFilename
        ) != 0 {
            System.fail(1, "Post-build pass failed\n");
        }
        uiEndpoints.add(UiEndpoint(uri, wasmFilename, title));
    }

    func addBeEndpoints (parent: ref[Core.Basic.TiObject]) {
        def elements: Array[ref[Core.Basic.TiObject]] = Spp.astMgr.findElements(
            ast { modifier == "beEndpoint" || modifier == "منفذ_بياني" },
            parent,
            Spp.SeekerFlags.SKIP_OWNERS | Spp.SeekerFlags.SKIP_USES | Spp.SeekerFlags.SKIP_CHILDREN
        );
        def i: Int;
        for i = 0, i < elements.getLength(), ++i {
            def modifier: ref[Core.Basic.TiObject](Spp.astMgr.findModifierForElement(elements(i), "beEndpoint"));
            if modifier~ptr == 0 modifier~no_deref = Spp.astMgr.findModifierForElement(elements(i), "منفذ_بياني");
            def endpointParams: Array[String];
            if !Spp.astMgr.getModifierStringParams(modifier, endpointParams)
                || endpointParams.getLength() < 2 {
                System.fail(1, "Invalid BE endpoint params");
            }
            Spp.astMgr.insertAst(
                ast {
                    if String.isEqual(method, "{{endpointMethod}}") && String.isEqual(uri, "{{endpointUri}}" ) {
                        fullref(connection);
                        return 1;
                    }
                },
                AstTemplateMap()
                    .set(Srl.String("endpointMethod"), Core.Basic.TiStr(endpointParams(0)))
                    .set(Srl.String("endpointUri"), Core.Basic.TiStr(endpointParams(1)))
                    .set(Srl.String("fullref"), constructElementFullReference(elements(i)))
            );
        }
    }

    func addAssetRoutes (parent: ref[Core.Basic.TiObject]) {
        def elements: Array[ref[Core.Basic.TiObject]] = Spp.astMgr.findElements(
            ast { modifier == "assetsRoute" || modifier == "مسار_موارد" },
            parent,
            Spp.SeekerFlags.SKIP_OWNERS | Spp.SeekerFlags.SKIP_USES | Spp.SeekerFlags.SKIP_CHILDREN
        );
        def i: Int;
        for i = 0, i < elements.getLength(), ++i {
            def endpointParams: Array[String];
            if !Core.Basic.isDerivedFrom[elements(i), Core.Data.Ast.StringLiteral] {
                System.fail(1, "Invalid asset route");
            }
            def path: String = Core.Basic.dynCastRef[elements(i), Core.Data.Ast.StringLiteral].value.value;
            if path(0) == '/' || path(0) == '.' {
                System.fail(1, String("Invalid asset route element; path should not start with / or .: ") + path);
            }
            addAssetRoute(String("/") + path, path);
        }
    }

    func addAssetRoute (uri: String, path: String) {
        validateAssetRoute(uri, path);
        assetRoutes.add(AssetRoute(uri, path));
    }

    func validateAssetRoute(uri: String, path: String) {
        if uri.getLength() == 0 {
            System.fail(1, "Invalid asset route; path is empty");
        }
        if uri(0) != '/' {
            System.fail(1, String("Invalid asset route; uri should start with /: ") + uri);
        }
        if uri(uri.getLength() - 1) != '/' {
            System.fail(1, String("Invalid asset route; uri should end with /: ") + uri);
        }
        if path(path.getLength() - 1) != '/' {
            System.fail(1, String("Invalid asset route; path should end with /: ") + path);
        }
    }

    func startServer [parent: ast_ref = Root] (options: ref[Array[CharsPtr]]): ptr[Http.Context] {
        addUiEndpoints(parent~ast);
        addAssetRoutes(parent~ast);
        if uiEndpoints.getLength() == 0 {
            System.fail(1, "No UI endpoints found\n");
        }
        htmlTemplate = Fs.readFile(webPlatformPath + "/wasm.html");

        options.add(0);

        return Http.startServer(callbackRequest[parent]~ptr, options);
    }

    func startServer [parent: ast_ref = Root] (optsCount: Int, opts: ...CharsPtr): ptr[Http.Context] {
        def options: Array[CharsPtr];
        while optsCount-- > 0 options.add(opts~next_arg[CharsPtr]);
        return startServer[parent](options);
    }

    func runServer [parent: ast_ref = Root] (optsCount: Int, opts: ...CharsPtr) {
        def options: Array[CharsPtr];
        while optsCount-- > 0 options.add(opts~next_arg[CharsPtr]);

        def context: ptr[Http.Context] = startServer[parent](options);
        Console.print("Server started.\npress enter to close server: ");
        Console.getChar(); // stop proccess here waiting user to press enter
        Http.stopServer(context); // stop the server
    }

    func callbackRequest [parent: ast_ref = Root] (connection: ptr[Http.Connection]): Int {
        def requestInfo: ptr[Http.RequestInfo] = Http.getRequestInfo(connection);
        def uri: ptr[array[Char]] = requestInfo~cnt.requestUri;
        def method: ptr[array[Char]] = requestInfo~cnt.requestMethod;

        preprocess { addBeEndpoints(parent~ast) };

        if String.isEqual(method, "GET") {
            if String.isEqual(uri, "/api.js") {
                Http.sendFile(connection, webPlatformPath + "/api.js");
                return 1;
            }

            def i: Int;
            for i = 0, i < assetRoutes.getLength(), ++i {
                if String.find(uri, assetRoutes(i).uri) == uri {
                    def fileName: String = assetRoutes(i).path + (uri + assetRoutes(i).uri.getLength());
                    if Fs.exists(fileName) {
                        Http.sendFile(connection, fileName);
                        return 1;
                    }
                }
            }

            for i = 0, i < uiEndpoints.getLength(), ++i {
                if uiEndpoints(i).filename == uri {
                    Http.sendFile(connection, String("/tmp") + uri);
                    return 1;
                } else {
                    def len: ArchInt = uiEndpoints(i).uri.getLength();
                    if uiEndpoints(i).uri == uri or (
                        len > 0 and uiEndpoints(i).uri(len - 1) == '*' and
                        String.compare(uiEndpoints(i).uri, uri, len - 1) == 0
                    ) {
                        sendHtmlTemplate(connection, uiEndpoints(i).title, uiEndpoints(i).filename);
                        return 1;
                    }
                }
            }
        }

        def content: array[Char, 1024];
        String.assign(content~ptr, "<h1>404 - Not Found</h1><p> you are in \"%s\"", requestInfo~cnt.localUri);
        Http.print(connection, "HTTP/1.1 404 Not Found\r\n");
        Http.print(connection, "Content-Type: text/html\r\n");
        Http.print(connection, "Content-Length: %d\r\n\r\n", String.getLength(content~ptr));
        Http.print(connection, content~ptr);

        return 1;
    }

    func sendHtmlTemplate (connection: ptr[Http.Connection], title: ptr[array[Char]], wasmFilename: ptr[array[Char]]) {
        def content: String = String.format(htmlTemplate, title, wasmFilename);
        def responseTemplate:
            "HTTP/1.1 200 OK\r\n"
            "Content-Type: text/html\r\n"
            "Content-Length: %d\r\n"
            "Connection: close\r\n"
            "Accept-Ranges: bytes\r\n\r\n"
            "%s";
        Http.print(connection, responseTemplate, content.getLength(), content.buf);
    }
}

