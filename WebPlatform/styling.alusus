@merge module WebPlatform {
    macro generateStringStyleProp [propName, styleName] {
        handler this.propName = (val: CharsPtr) {
            this.props(String(styleName)) = String(val);
            this.onPropUpdated();
            return val;
        }
        handler this.propName = (val: ref[String]) {
            this.props(String(styleName)) = val;
            this.onPropUpdated();
            return val;
        }
        handler this.propName: ref[String] {
            return this.props(String(styleName));
        }
    }

    macro generateColorStyleProp [propName, styleName] {
        handler this.propName = (val: ref[Color]) {
            this.props(String(styleName)) = String.format(
                "rgba(%i, %i, %i, %i)", val.red, val.green, val.blue, val.alpha
            );
            this.onPropUpdated();
            return val;
        }
        generateStringStyleProp[propName, styleName];
    }

    macro generateFloatStyleProp [propName, styleName] {
        handler this.propName = (val: Float) {
            this.props(String(styleName)) = String.format("%fpt", val);
            this.onPropUpdated();
            return val;
        }
        generateStringStyleProp[propName, styleName];
    }

    macro generateQuadStyleProp [propName, styleName] {
        handler this.propName = (val: ref[Quad]) {
            this.props(String(styleName)) = String.format(
                "%fpt %fpt %fpt %fpt", val.top, val.right, val.bottom, val.left
            );
            this.onPropUpdated();
            return val;
        }
        generateStringStyleProp[propName, styleName];
    }

    //==========================================================================
    // Styles
    // Holds styling properties for widgets.
    class Style {
        // Variables

        def id: String;
        def selector: String;
        def props: Map[String, String];
        def onUpdated: closure();

        // Properties

        generateStringStyleProp[width, "width"];
        generateStringStyleProp[height, "height"];
        generateStringStyleProp[minWidth, "min-width"];
        generateStringStyleProp[minHeight, "min-height"];
        generateStringStyleProp[maxWidth, "max-width"];
        generateStringStyleProp[maxHeight, "max-height"];
        generateQuadStyleProp[border, "border"];
        generateColorStyleProp[borderColor, "border-color"];
        generateQuadStyleProp[borderRadius, "border-radius"];
        generateStringStyleProp[borderStyle, "border-style"];
        generateStringStyleProp[position, "position"];
        generateStringStyleProp[zIndex, "z-index"];
        generateStringStyleProp[flex, "flex"];
        generateStringStyleProp[layout, "flex-direction"];
        generateStringStyleProp[justify, "justify-content"];
        generateQuadStyleProp[margin, "margin"];
        generateStringStyleProp[align, "align-items"];
        generateStringStyleProp[textAlign, "text-align"];
        generateStringStyleProp[direction, "direction"];
        generateQuadStyleProp[padding, "padding"];
        generateFloatStyleProp[fontSize, "font-size"];
        generateColorStyleProp[fontColor, "color"];
        generateStringStyleProp[transition, "transition"];
        generateStringStyleProp[transform, "transform"];
        generateStringStyleProp[translate, "translate"];
        generateStringStyleProp[overflow, "overflow"];
        generateStringStyleProp[boxShadow, "box-shadow"];
        generateStringStyleProp[display, "display"];
        generateStringStyleProp[cursor, "cursor"];
        generateStringStyleProp[top, "top"];
        generateStringStyleProp[left, "left"];
        generateStringStyleProp[right, "right"];
        generateStringStyleProp[bottom, "bottom"];
        generateColorStyleProp[background, "background"];

        def vanimation: SrdRef[Animation];
        handler this.animation = (val: SrdRef[Animation]) {
            if !this.vanimation.isNull() and this.id != "" this.vanimation.unbuild();
            this.vanimation = val;
            if !this.vanimation.isNull() and this.id != "" this.vanimation.build();
            this.onPropUpdated();
            return this.vanimation;
        }
        handler this.animation: SrdRef[Animation] {
            return this.vanimation;
        }

        // Initializers and Operators

        handler this~init() {}

        handler this~init(ref[Style]) {
            this = value;
        }

        handler this = ref[Style] {
            this.props = value.props;
            this.vanimation = value.vanimation;
            this.onPropUpdated();
        }

        // Functions

        handler this.onPropUpdated() {
            if !this.onUpdated.isNull() this.onUpdated();
            this.update();
        }

        handler this.build(id: String, selector: String) {
            this.id = id;
            this.selector = selector;
            if !this.vanimation.isNull() this.vanimation.build();
            this.update();
        }

        handler this.unbuild() {
            if this.id == "" return;
            if !this.vanimation.isNull() this.vanimation.unbuild();
            removeStyleRule(this.id, this.selector);
        }

        handler this.update() {
            if this.id == "" return;
            setStyleRule(this.id, this.selector, this.getCssString());
        }

        handler this.getCssString(): String {
            def styleRep: String;
            def i: Int;
            for i = 0, i < this.props.getLength(), ++i {
                styleRep += this.props.keyAt(i) + ":" + this.props.valAt(i) + ";";
            }
            if !this.vanimation.isNull() {
                styleRep += String.format("animation-name:%s;", this.vanimation.name.buf);
                styleRep += String.format("animation-duration:%fs;", this.vanimation.totalDuration);
            }
            return styleRep;
        }
    }

    //==========================================================================
    // StyleSet
    // Manages a set of styles for an element in different states.
    class StyleSet {
        @injection def mainStyle: Style;
        def otherStyles: Map[String, Style];
        def className: String = getNewId();
        def buildCounter: Int = 0;

        handler this~init() {}

        handler this(state: CharsPtr): ref[Style] {
            return this({ state });
        }

        handler this(count: Int, selectors: ...[CharsPtr, 1]): ref[Style] {
            def fullSelector: String;
            while count-- > 0 {
                def selector: CharsPtr = selectors~next_arg[CharsPtr];
                if selector~cnt(0) != ':' fullSelector += " .";
                fullSelector += selector;
            }
            return this.otherStyles(fullSelector);
        }

        handler this.build() {
            if this.buildCounter++ > 0 return;

            createElement("style", this.className, "body");
            def selector: String = String(".") + this.className;
            this.mainStyle.build(this.className, selector);
            def i: Int;
            for i = 0, i < this.otherStyles.getLength(), i++ {
                this.otherStyles.valAt(i).build(this.className, selector + this.otherStyles.keyAt(i));
            }
        }

        handler this.unbuild() {
            if this.buildCounter == 0 return;
            if --this.buildCounter > 0 return;

            deleteElement(this.className);
            this.mainStyle.unbuild();
            def i: Int;
            for i = 0, i < this.otherStyles.getLength(), i++ {
                this.otherStyles.valAt(i).unbuild();
            }
        }

        handler this_type(): SrdRef[StyleSet] {
            return SrdRef[StyleSet].construct();
        }
    }

    //==========================================================================
    // StateSelector
    // Selectors for different states of a widget.
    def StateSelector: {
        def ACTIVE: ":active";
        def CHECKED: ":checked";
        def DEFAULT: ":default";
        def DISABLED: ":disabled";
        def EMPTY: ":empty";
        def ENABLED: ":enabled";
        def FOCUS: ":focus";
        def FULLSCREEN: ":fullscreen";
        def HOVER: ":hover";
        def IN_RANGE: ":in-range";
        def INTERMEDIATE: ":indeterminate";
        def INVALID: ":invalid";
        def LINK: ":link";
        def OPTIONAL: ":optional";
        def OUT_OF_RANGE: ":out-of-range";
        def READ_ONLY: ":read-only";
        def READ_WRITE: ":read-write";
        def REQUIRED: ":required";
        def TARGET: ":target";
        def VALID: ":valid";
        def VISITED: ":visited";
    }

    //==========================================================================
    // Animation
    // class to deal with keyframes and animation
    class Animation {
        def name : String = getNewId();
        def buildCounter: Int = 0;
        def styles: Map[Float, Style];
        def totalDuration: Float;
        def onUpdated: closure() = closure() {
            this.update();
        }

        handler this~init() {}
        handler this~init(styles: Array[Style]) this.set(styles);
        handler this~init(styles: Map[Float, Style]) this.set(styles);

        handler this.set(totalDuration: Float, styles: Array[Style]) {
            this.totalDuration = totalDuration;
            this.styles.values = styles;

            def i: Int = 0;
            def sectionSize: Float = 100f / (styles.getLength() - 1);
            for i = 0, i < styles.getLength(), i += 1 {
                this.styles.keys.add(i * sectionSize);
                this.styles.values(i).onUpdated = this.onUpdated;
            }
        }
        handler this.set(totalDuration: Float, styles: Map[Float, Style]) {
            this.totalDuration = totalDuration;
            this.styles = styles;

            def i: Int = 0;
            for i = 0, i < this.styles.getLength(), i += 1 {
                this.styles(i).onUpdated = this.onUpdated;
            }
        }

        handler this.build() {
            if this.buildCounter++ > 0 return;

            createElement("style", this.name, "body");
            this.update();
        }

        handler this.unbuild() {
            if this.buildCounter == 0 return;
            if --this.buildCounter > 0 return;

            deleteElement(this.name);
        }

        handler this.update() {
            if this.buildCounter == 0 return;

            def cssString: String = String("@keyframes ") + this.name + String(" {");
            def i: Int;
            for i = 0, i < this.styles.getLength(), ++i {
                cssString = cssString + this.styles.keyAt(i) + "% {" + this.styles(i).getCssString() + "}";
            }
            cssString += String("}");
            setElementAttribute(this.name, "innerHTML", cssString);
        }

        handler this_type(): SrdRef[Animation] {
            return SrdRef[Animation].construct();
        }
        handler this_type(d: Float, s: Array[Style]): SrdRef[Animation] {
            return SrdRef[Animation].construct().{ set(d, s) };
        }
        handler this_type(d: Float, s: Map[Float, Style]): SrdRef[Animation] {
            return SrdRef[Animation].construct().{ set(d, s) };
        }
    }
}

